## PythonによるOpenFOAMのパラメトリックスタディ

一つの条件の結果を得てもいいが、一応条件を振ってみて温度により熱伝達率が大きく変わらないかどうかを確認

|   | target  | パラスタmin | パラスタmax |
| :-: | :-: | :-: | :-: |
| 表面温度 | 10 | 0 | 20 |
| 外気温度 | -18 | -20 | 16 | 

---

## 1. 元となるケースの作成

- ソルバー：buoyantSimpleFoam
- 缶の表面温度を複数条件でパラメトリックスタディする

```
├── Allrun
├── Allclean
├── caseProperties # これが大事！
├── 0
│   └── T,U,p,p_rgh
├── constant
│   ├── g
│   ├── polyMesh
│   ├── thermophysicalProperties
│   └── turbulenceProperties
└── system
    ├── controlDict
    ├── fvScheme
    ├── fvSchemes
    └── fvSolution
```

---

## 2. パラメトリックスタディの準備

- ディクショナリファイルを作成
- 0/Tでこれをincludeするように設定

includeするディクショナリファイル `./caseProperties`

```cpp:caseProperties
T_out   253; // これを呼び出す
T_in    300; // これを呼び出す
```


温度境界条件 `./0/T`

```cpp
#include "../caseProperties" // ここで読み込む

dimensions [ 0 0 0 1 0 0 0 ];
internalField uniform $T_out; // ここで使う

boundaryField {
    ".*" {
        type fixedValue;
        value uniform $T_out; // ここで使う
    }
    ".*(gas|liq)" {
        type fixedValue;
        value uniform $T_in; // ここで使う
    }
}
```

---

## 3. ソルバーを実行するPython関数

- Pythonの関数内で以下の操作を行う
  - 先程の`./caseProperties`をPyFoamで変更する
  - ソルバーを実行

```Python
import subprocess, shutil
from pathlib import Path
from PyFoam.RunDictionary.ParsedParameterFile import ParsedParameterFile

orgCase = Path('../case/350mL_3D/org_wedge')
studyDir = Path('../case/350mL_3D/study_wedge')
```

```Python
def runCase(T_in, T_out):
    name = 'wedge_{:.0f}_{:.0f}'.format(T_in, T_out)
    newCase = studyDir / name
    shutil.copytree(orgCase, newCase)
    with ParsedParameterFile(newCase / 'system/controlDict') as controlDict:
        app = controlDict.content['application'] # controlDictからソルバーの名前を取り出す
    with ParsedParameterFile(newCase / 'caseProperties') as caseProperties:
        caseProperties.content['T_in'] = T_in  # 先程のディクショナリファイルを書き換える
        caseProperties.content['T_out'] = T_out
        caseProperties.writeFile()
    command = [app, '-case', newCase]
    # ソルバーを実行
    log = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    return [T_in, T_out, newCase, log]
```

---

## 4. Pyhton上でパラメトリックスタディ（並列）

- 今回のようなメッシュ数の少ないケースではOpenFOAMでの並列効率が悪い
- シリアル計算を**Python上で並列実行**すると効率が良い

```Python
# 例：T_inとT_outをそれぞれ8パターン×3パターンで行う場合
from joblib import Parallel, delayed

T_in_list = np.arange(263,299,5.0) # [263,268,273,278,283,288,293,298]
T_out_list = np.arange(253,258,2.0) # [253,255,257]

result = Parallel(n_jobs=12)([delayed(runCase)(T_in, T_out) for T_in, T_out in itertools.product(T_in_list, T_out_list)])
```

---

## 5. 結果の抽出

- functionObjectで出力されたファイルをpandasで読み込む
- `./postProcessing/heatFlux/0/wallHeatFlux`
- その中の最終時刻の値を抽出

```Python
flux = {'gas':{}, 'liq':{}}
for d in studyDir.glob("*"):
    if not d.is_dir(): continue
    with ParsedParameterFile(d / 'caseProperties') as caseProperties:
        T_in = caseProperties.content['T_in']
        T_out = caseProperties.content['T_out'] # 書き換えられた値を読み込む
    TFile = d / 'postProcessing/heatFlux/0/wallHeatFlux.dat'
    index = ['time', 'patch', 'min', 'max', 'integral', 'nan']
    T = pd.read_csv(TFile, skiprows=2, sep='\s+| |\t|# ', names=index)
    for key in ['liq', 'gas']:
        flux[key][(T_in, T_out)] = T[T['patch'] == 'wall_'+key]['integral'].values[-1]
```

---

## 6. 得られた結果

- 表面10℃/外気-18℃の時に熱伝達率は6.0 [W/m2/K]
- これを用いて内部流れの非定常計算を行う
- 表面温度が5℃になるまでくらいならこの値でいけそう

![](fig/heattrans_plot.png)

---

## いよいよビールの計算 →
